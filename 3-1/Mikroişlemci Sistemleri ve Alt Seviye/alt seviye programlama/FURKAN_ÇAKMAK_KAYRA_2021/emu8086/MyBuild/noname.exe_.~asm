SSEG     SEGMENT PARA STACK 'STACK'
DQ 123 DUP (?)
SSEG     ENDS

DSEG    SEGMENT PARA 'DATA'
CR    EQU 13
LF    EQU 10
MSG1    DB 'N degerini giriniz: ',0
MSG2    DB CR, LF, 'Elemani giriniz: ', 0
HATA    DB CR, LF, 'Dikkat !!! Sayi vermediniz yeniden giris yapiniz.!!!  ', 0
SONUC    DB CR, LF, 'Toplam ', 0
N       DW ?
dizi    DW 100 DUP(?)
link    DW 100 DUP(?)
enkck   DW ?
DSEG     ENDS

CSEG     SEGMENT PARA 'CODE'
ASSUME CS:CSEG, DS:DSEG, SS:SSEG
SIRALAMA MACRO dizi,link,N
LOCAL   L1,L2,L3,L4,L5,L6
LEA DI,dizi
XOR SI,SI
L6:
MOV link[SI],DI
ADD DI,2
ADD SI,2
LOOP L6
MOV CX,N
XOR SI,SI
KL2: PUSH dizi[SI]
ADD SI,2
LOOP KL2


MOV CX,N
XOR BX,BX
XOR SI,SI
L4: PUSH CX
MOV AX,N
SUB AX,CX
SHL AX,1
MOV SI,AX
MOV AX,dizi[SI]
MOV enkck,AX
L3: MOV AX,dizi[SI]
CMP AX,enkck
JG  L1
MOV enkck,AX
MOV DI,SI
L1:ADD SI,2
LOOP L3
PUSH DI
MOV SI,DI
MOV DI,dizi[SI]
XCHG DI,dizi[BX]
MOV dizi[SI],DI
POP DI
MOV SI,DI
MOV DI,link[SI]
XCHG DI,link[BX]
MOV link[SI],DI
POP CX
ADD BX,2
LOOP L4
PUSH AX
MOV CX,N
MOV AX,N
SHL AX,1
SUB AX,2
MOV SI,AX
POP AX
L5: POP dizi[SI]
SUB SI,2
LOOP L5
ENDM
ANA     PROC FAR
PUSH DS
XOR AX,AX
PUSH AX
MOV AX, DSEG
MOV DS, AX
MOV AX, OFFSET MSG1
CALL PUT_STR                    ; MSG1’i göster
CALL GETN                      ; N’i oku
MOV N, AX
MOV CX,N
XOR SI,SI
L1:     MOV AX, OFFSET MSG2
CALL PUT_STR                    ; MSG2’i göster
CALL GETN                         ; SAYI2’i oku
MOV dizi[SI], AX
ADD SI,2
LOOP L1
SIRALAMA dizi,link,N
MOV CX,N

RETF
ANA     ENDP


GETC    PROC NEAR
;------------------------------------------------------------------------
; Klavyeden basýlan karakteri AL yazmacýna alýr ve ekranda gösterir.
; iþlem sonucunda sadece AL etkilenir.
;------------------------------------------------------------------------
MOV AH, 1h
INT 21H
RET
GETC    ENDP

PUTC    PROC NEAR
;------------------------------------------------------------------------
; AL yazmacýndaki deðeri ekranda gösterir. DL ve AH deðiþiyor. AX ve DX
; yazmaçlarýnýn deðerleri korumak için PUSH/POP yapýlýr.
;------------------------------------------------------------------------
PUSH AX
PUSH DX
MOV DL, AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTC     ENDP

GETN     PROC NEAR
;------------------------------------------------------------------------
; Klavyeden basýlan sayiyi okur, sonucu AX yazmacý üzerinden dondurur.
; DX: sayýnýn iþaretli olup/olmadýðýný belirler. 1 (+), -1 (-) demek
; BL: hane bilgisini tutar
; CX: okunan sayýnýn islenmesi sýrasýndaki ara deðeri tutar.
; AL: klavyeden okunan karakteri tutar (ASCII)
; AX zaten dönüþ deðeri olarak deðiþmek durumundadýr. Ancak diðer
; yazmaçlarýn önceki deðerleri korunmalýdýr.
;------------------------------------------------------------------------
PUSH BX
PUSH CX
PUSH DX
GETN_START:
MOV DX, 1                            ; sayýnýn þimdilik + olduðunu varsayalým
XOR BX, BX                             ; okuma yapmadý Hane 0 olur.
XOR CX,CX                            ; ara toplam deðeri de 0’dýr.
NEW:
CALL GETC                            ; klavyeden ilk deðeri AL’ye oku.
CMP AL,CR
JE FIN_READ                            ; Enter tuþuna basilmiþ ise okuma biter
CMP  AL, '-'                            ; AL ,'-' mi geldi ?
JNE  CTRL_NUM                            ; gelen 0-9 arasýnda bir sayý mý?
NEGATIVE:
MOV DX, -1                            ; - basýldý ise sayý negatif, DX=-1 olur
JMP NEW                                ; yeni haneyi al
CTRL_NUM:
CMP AL, '0'                            ; sayýnýn 0-9 arasýnda olduðunu kontrol et.
JB error
CMP AL, '9'
JA error                        ; deðil ise HATA mesajý verilecek
SUB AL,'0'                            ; rakam alýndý, haneyi toplama dâhil et
MOV BL, AL                            ; BL’ye okunan haneyi koy
MOV AX, 10                             ; Haneyi eklerken *10 yapýlacak
PUSH DX                                ; MUL komutu DX’i bozar iþaret için saklanmalý
MUL CX                                ; DX:AX = AX * CX
POP DX                                ; iþareti geri al
MOV CX, AX                            ; CX deki ara deðer *10 yapýldý
ADD CX, BX                             ; okunan haneyi ara deðere ekle
JMP NEW                         ; klavyeden yeni basýlan deðeri al
ERROR:
MOV AX, OFFSET HATA
CALL PUT_STR                            ; HATA mesajýný göster
JMP GETN_START                          ; o ana kadar okunanlarý unut yeniden sayý almaya baþla
FIN_READ:
MOV AX, CX                            ; sonuç AX üzerinden dönecek
CMP DX, 1                            ; Ýþarete göre sayýyý ayarlamak lazým
JE FIN_GETN
NEG AX                                ; AX = -AX
FIN_GETN:
POP DX
POP CX
POP DX
RET
GETN     ENDP

PUTN     PROC NEAR
;------------------------------------------------------------------------
; AX de bulunan sayiyi onluk tabanda hane hane yazdýrýr.
; CX: haneleri 10’a bölerek bulacaðýz, CX=10 olacak
; DX: 32 bölmede iþleme dâhil olacak. Soncu etkilemesin diye 0 olmalý
;------------------------------------------------------------------------
PUSH CX
PUSH DX
XOR DX,    DX                             ; DX 32 bit bölmede soncu etkilemesin diye 0 olmalý
PUSH DX                                ; haneleri ASCII karakter olarak yýðýnda saklayacaðýz.
; Kaç haneyi alacaðýmýzý bilmediðimiz için yýðýna 0
; deðeri koyup onu alana kadar devam edelim.
MOV CX, 10                            ; CX = 10
CMP AX, 0
JGE CALC_DIGITS
NEG AX                                 ; sayý negatif ise AX pozitif yapýlýr.
PUSH AX                                ; AX sakla
MOV AL, '-'                            ; iþareti ekrana yazdýr.
CALL PUTC
POP AX                                ; AX’i geri al

CALC_DIGITS:
DIV CX                          ; DX:AX = AX/CX  AX = bölüm DX = kalan
ADD DX, '0'                            ; kalan deðerini ASCII olarak bul
PUSH DX                                ; yýðýna sakla
XOR DX,DX                            ; DX = 0
CMP AX, 0                            ; bölen 0 kaldý ise sayýnýn iþlenmesi bitti demek
JNE CALC_DIGITS                            ; iþlemi tekrarla

DISP_LOOP:
; yazýlacak tüm haneler yýðýnda. En anlamlý hane üstte
; en az anlamlý hane en alta ve onu altýnda da
; sona vardýðýmýzý anlamak için konan 0 deðeri var.
POP AX                                ; sýrayla deðerleri yýðýndan alalým
CMP AX, 0                             ; AX=0 olursa sona geldik demek
JE END_DISP_LOOP
CALL PUTC                             ; AL deki ASCII deðeri yaz
JMP DISP_LOOP                           ; iþleme devam

END_DISP_LOOP:
POP DX
POP CX
RET
PUTN     ENDP

PUT_STR    PROC NEAR
;------------------------------------------------------------------------
; AX de adresi verilen sonunda 0 olan dizgeyi karakter karakter yazdýrýr.
; BX dizgeye indis olarak kullanýlýr. Önceki deðeri saklanmalýdýr.
;------------------------------------------------------------------------
PUSH BX
MOV BX,    AX                    ; Adresi BX’e al
MOV AL, BYTE PTR [BX]                    ; AL’de ilk karakter var
PUT_LOOP:
CMP AL,0
JE  PUT_FIN                     ; 0 geldi ise dizge sona erdi demek
CALL PUTC                     ; AL’deki karakteri ekrana yazar
INC BX                         ; bir sonraki karaktere geç
MOV AL, BYTE PTR [BX]
JMP PUT_LOOP                    ; yazdýrmaya devam
PUT_FIN:
POP BX
RET
PUT_STR    ENDP

CSEG     ENDS
END ANA

